<!---
markmeta_author: titlwind
markmeta_date: 2023-05-23
markmeta_title: hessian golang 序列化库设计回顾
markmeta_categories: design
markmeta_tags: hessian,design,retrospection
-->

# hessian golang 序列化库设计回顾

2019年，当时计划用golang重写公司的Java api 网关, 网关用到了dubbo的泛化调用，底层是用hessian序列化协议，
但golang当时是没有比较稳定的实现，当时找到于雨实现的版本和[viant/gohessian](https://github.com/viant/gohessian)都存在bug，
于是就自己实现了一个[版本](https://github.com/vogo/gohessian), 并实现了golang api网关的功能，实测是原来Java网关3倍的性能，但因为诸多原因，网关也没有上线。
后来于雨找到我说一起去搞一个dubbo 的 golang hessian 开源版本 [dubbo-go-hessian2](https://github.com/apache/dubbo-go-hessian2)，抱着对开源的热情便欣然同意了。

几年来一直断断续续不断重构改进该协议库，一有issue问题提出，就会去思考怎么解决。
有些问题并不好解决，但一直想着，总会想到解决方案。
有时候在睡梦中思路就想通了，抓着周末或下班时间赶紧修复改进。
一直维护到现在的原因，除了热情，另外就是责任。
想到有很多人在用这个库，出了问题是很着急的，可能要花比较多时间来熟悉，方案不一定考虑全面，还是自己花点时间解决比较妥当。

hessian协议本身是基于java设计的，夹带了一些java语言的特性。 hessian协议除了上手容易这个特点外，在与其他序列化协议比较中并不占优势，想着使用的人会慢慢减少。
但作为dubbo框架的默认序列号协议，随着dubbo的火爆，hessian协议也持续被广泛使用着，而且还有公司要继续去重新实现一遍golang hessian协议。
我想有必要整理一些之前设计遇到的问题和注意点，可以为大家做参考。


## 向后兼容

序列化协议库作为底层库，在API设计、特性功能设计上是要特别注意的，一旦发布了正式版本，则后续版本都要支持原有的设计，做到向后兼容。
底层库设计上的修改如果会影响上层应用，要求上层应用跟着改动，是会带来很大的民怨，是不符合开源软件的精神，对开源软件的发展也会带来不利的影响。

所以在设计上要谨慎，建议面向用户的API都应该准备好用户使用范例，经过团队讨论后，再最终敲定。
可以整理一份API列表、一份特性功能列表，这些设计将指引底层库细节设计的考虑，让编码、评审等工作目标更加明确。

比如定义对象名的方法名 `JavaClassName` 一旦确认了，后面都要继续支持使用该方法。
新增兼容方法可以解决问题，但会是实现变得复杂，同时会出现多重用法，给使用者增加了额外的认知负担。

## 谨慎考虑支持的特性范围

特性范围也算是向后兼容要考虑的，单独列出来是因为对特性的选择两难的问题。
特性支持得多，对用户体验更友好，在用户选型时更容易拿高分。
但特性支持得多，底层设计越复杂，越容易出BUG。
要在使用体验和复杂性之间做权衡。
最好的选择是刚好满足用户的需求的同时底层设计又不那么复杂。

对于引用关系，Java里面是对象引用，Golang里面是通过指针，但golang里面有多层的指针。
hessian的golang实现要不要支持多层指针呢？ 
如果支持，对用户体验来说是更好，用户在struct定义上就没有指针层级的限制，但实现复杂度上了一个台阶，很多地方都要考虑。
也因为这个导致了很多issue。
如果不支持，绝大多数用户也不会用到，影响面不大，可以考虑作为协议支持特性进行说明，实现上就会简单很多。

## 跨语言的目标

## 完善的单元测试

## 字符串编码

## 引用关系和循环依赖


## A. History

- 2023-05-23, 整理初稿